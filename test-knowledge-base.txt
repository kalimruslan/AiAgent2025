Kotlin Multiplatform (KMP) - Справочник

Что такое Kotlin Multiplatform?
Kotlin Multiplatform - это технология от JetBrains, которая позволяет разработчикам создавать кроссплатформенные приложения с общей бизнес-логикой. Код пишется один раз на Kotlin и может работать на Android, iOS, Desktop, Web и других платформах.

Основные преимущества KMP:
1. Общая кодовая база - бизнес-логика пишется один раз
2. Нативная производительность - код компилируется в нативный для каждой платформы
3. Постепенная миграция - можно внедрять KMP поэтапно в существующие проекты
4. Доступ к платформенным API через expect/actual механизм

Архитектура KMP проекта:
KMP проекты обычно состоят из нескольких модулей:
- commonMain - общий код для всех платформ
- androidMain - Android-специфичный код
- iosMain - iOS-специфичный код
- desktopMain - Desktop-специфичный код

Механизм expect/actual:
Это ключевой механизм KMP для работы с платформенными различиями. В commonMain объявляется expect-функция или класс, а в платформенных модулях предоставляется actual реализация.

Пример:
// commonMain
expect fun getPlatformName(): String

// androidMain
actual fun getPlatformName(): String = "Android"

// iosMain
actual fun getPlatformName(): String = "iOS"

Compose Multiplatform:
Compose Multiplatform - это декларативный UI фреймворк от JetBrains для создания пользовательских интерфейсов на Kotlin Multiplatform. Позволяет использовать Jetpack Compose не только на Android, но и на iOS, Desktop и Web.

Особенности Compose Multiplatform:
1. Единый декларативный подход к UI
2. Реактивное управление состоянием через State
3. Переиспользование UI компонентов между платформами
4. Поддержка Material Design 3

Управление зависимостями в KMP:
В KMP проектах используется Gradle с Kotlin DSL. Зависимости объявляются для каждого source set отдельно:
- commonMain - общие зависимости (kotlinx-coroutines, ktor-client-core)
- androidMain - Android зависимости (ktor-client-android)
- iosMain - iOS зависимости (ktor-client-darwin)

Популярные библиотеки для KMP:
1. Ktor - HTTP клиент и сервер
2. Kotlinx.serialization - сериализация JSON
3. Kotlinx.coroutines - асинхронное программирование
4. SQLDelight или Room - базы данных
5. Koin - dependency injection
6. Kotlinx.datetime - работа с датами

Сетевое взаимодействие в KMP:
Ktor Client - это кроссплатформенный HTTP клиент для Kotlin Multiplatform. Он предоставляет единый API для всех платформ, но использует разные движки (engines) для каждой платформы.

Пример создания Ktor клиента:
val client = HttpClient(engine) {
    install(ContentNegotiation) {
        json()
    }
    install(Logging)
}

Базы данных в KMP:
Room и SQLDelight - две популярные библиотеки для работы с базами данных в KMP. Room теперь поддерживает KMP начиная с версии 2.7. SQLDelight генерирует типобезопасный Kotlin код из SQL запросов.

Преимущества Room в KMP:
1. Знакомый API для Android разработчиков
2. Поддержка coroutines и Flow
3. Миграции базы данных
4. Компилятор проверяет SQL запросы

Dependency Injection в KMP:
Koin - популярная библиотека DI для KMP. Она легковесная и не требует кодогенерации. Поддерживает все платформы KMP.

Пример Koin модуля:
val appModule = module {
    single<Repository> { RepositoryImpl(get()) }
    viewModel { MyViewModel(get()) }
}

Тестирование в KMP:
KMP поддерживает написание общих тестов в commonTest. Для платформенных тестов используются androidTest, iosTest и т.д.

Фреймворки для тестирования:
1. kotlin.test - общая библиотека для тестирования
2. Kotlinx.coroutines.test - тестирование корутин
3. Turbine - тестирование Flow
4. MockK или Mockative - моки

Навигация в Compose Multiplatform:
Jetpack Navigation Compose теперь поддерживает KMP. Можно использовать type-safe navigation с помощью аннотации @Serializable для определения маршрутов.

Пример навигации:
@Serializable
object HomeRoute

@Serializable
data class DetailRoute(val id: String)

NavHost(navController, startDestination = HomeRoute) {
    composable<HomeRoute> { HomeScreen() }
    composable<DetailRoute> { DetailScreen() }
}

Работа с платформенными API:
Для доступа к платформенным API используется expect/actual механизм. Например, для работы с файловой системой, камерой, уведомлениями нужно создавать expect интерфейсы.

Best Practices для KMP:
1. Держите максимум кода в commonMain
2. Используйте expect/actual только когда действительно нужно
3. Проектируйте API так, чтобы минимизировать платформенные различия
4. Тестируйте общий код в commonTest
5. Используйте Clean Architecture для разделения слоёв

Gradle конфигурация KMP:
В KMP проектах используется kotlin-multiplatform плагин. Нужно явно указывать target платформы:
- android()
- iosX64(), iosArm64(), iosSimulatorArm64()
- jvm() для Desktop

Kotlinx.coroutines в KMP:
Корутины работают на всех платформах KMP. Основные диспетчеры:
- Dispatchers.Main - UI поток (работает везде благодаря kotlinx-coroutines-core)
- Dispatchers.IO - I/O операции
- Dispatchers.Default - вычисления

Flow в KMP:
Flow - это реактивный стрим из kotlinx.coroutines, который работает на всех платформах. Используется для реактивного программирования, замена LiveData.

StateFlow и SharedFlow:
StateFlow - горячий Flow с текущим значением, аналог LiveData
SharedFlow - горячий Flow без текущего значения, для событий

Ресурсы в KMP:
Для работы с ресурсами (строки, изображения) можно использовать библиотеку Moko Resources или организовать expect/actual подход.

Buildkonfig:
Библиотека для работы с build-time константами в KMP. Позволяет генерировать константы из gradle.properties.

Clean Architecture в KMP:
Типичная структура:
- domain - бизнес-логика, use cases, repository интерфейсы (commonMain)
- data - реализации репозиториев, API клиенты, БД (commonMain с expect/actual для специфики)
- presentation - UI, ViewModels (может быть платформенным или общим с Compose MP)

ViewModel в KMP:
Jetpack ViewModel теперь поддерживает KMP. Можно создавать общие ViewModels в commonMain и использовать их на всех платформах.

Пример ViewModel:
class MyViewModel : ViewModel() {
    private val _state = MutableStateFlow(State())
    val state: StateFlow<State> = _state.asStateFlow()

    fun loadData() {
        viewModelScope.launch {
            // async work
        }
    }
}

Сериализация в KMP:
Kotlinx.serialization - официальная библиотека сериализации для Kotlin. Работает на всех платформах через кодогенерацию во время компиляции.

Пример:
@Serializable
data class User(val name: String, val age: Int)

val json = Json.encodeToString(user)
val user = Json.decodeFromString<User>(json)

Логирование в KMP:
Популярные решения:
1. Kermit - кроссплатформенный логгер
2. Napier - простой логгер для KMP
3. Собственный expect/actual wrapper

Обработка ошибок в KMP:
Рекомендуется использовать sealed классы для представления результатов операций:

sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    data class Error(val message: String) : Result<Nothing>()
    object Loading : Result<Nothing>()
}

Многомодульность в KMP:
KMP проекты часто организуются в многомодульную структуру:
- core - общие утилиты
- domain - бизнес-логика
- data - данные
- features - feature-модули
- app - точка входа

Gradle Version Catalog:
Современный способ управления зависимостями через libs.versions.toml файл. Позволяет централизованно управлять версиями библиотек.

Convention Plugins:
Gradle convention plugins позволяют переиспользовать конфигурацию между модулями. Создаются в build-logic директории.

iOS интеграция:
KMP модуль для iOS может быть интегрирован:
1. Через CocoaPods
2. Через SPM (Swift Package Manager)
3. Как XCFramework

Memory Management в iOS:
Kotlin/Native использует новый memory manager, который не требует freeze объектов и работает похоже на JVM GC.

Настройки приложения в KMP:
Multiplatform Settings - библиотека для работы с настройками (SharedPreferences на Android, UserDefaults на iOS).

Image Loading в KMP:
Популярные библиотеки:
1. Coil3 - поддерживает KMP
2. Kamel - KMP image loading
3. Landscapist - Compose-first решение

Работа с JSON в KMP:
Kotlinx.serialization с Json formatter - стандартное решение. Поддерживает кастомизацию через JsonBuilder.

WebSocket в KMP:
Ktor Client поддерживает WebSocket на всех платформах через общий API.

OAuth и авторизация в KMP:
Можно реализовать через Ktor Client с установленным Auth feature. Для OAuth2 нужен expect/actual для открытия браузера.

Локализация в KMP:
Для локализации можно использовать Moko Resources или Lyricist библиотеки.

Производительность KMP:
KMP приложения имеют нативную производительность, так как компилируются:
- На Android - в JVM байткод
- На iOS - в native код через Kotlin/Native
- На Desktop - в JVM байткод

Hot Reload в Compose Multiplatform:
Compose Multiplatform поддерживает Hot Reload для быстрой разработки UI без перекомпиляции.

CI/CD для KMP:
KMP проекты можно собирать на CI:
- GitHub Actions
- GitLab CI
- Bitrise
- CircleCI

Требования:
- JDK для JVM/Android
- Xcode и Command Line Tools для iOS
- Gradle

Инструменты разработки:
1. IntelliJ IDEA / Android Studio - основные IDE
2. Fleet - новая IDE от JetBrains с KMP поддержкой
3. Xcode - для iOS части
4. Gradle - система сборки

KMP и Jetpack Libraries:
Многие Jetpack библиотеки теперь поддерживают KMP:
- Room
- DataStore
- Lifecycle (ViewModel)
- Navigation
- Paging

Будущее KMP:
JetBrains активно развивает KMP. Планы включают:
- Улучшение iOS интеграции
- Больше Jetpack библиотек с KMP поддержкой
- Улучшение тулинга и IDE
- Wasmобработку для Web